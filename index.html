<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>SQUAD TACTICS v2.0.1 - HEROES OF THE SECTOR</title>
    <style>
        :root { --bg: #0b0e0a; --panel: #1a1a1a; --text: #bbb; --accent: #d84; --border: #444; }
        body {
            background-color: #000; color: var(--text);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0; height: 100vh; display: flex; overflow: hidden;
            user-select: none;
        }

        #app { display: flex; width: 100%; height: 100%; }
        #game-view { flex: 1; position: relative; overflow: hidden; cursor: crosshair; background: var(--bg); }
        canvas { display: block; width: 100%; height: 100%; position: absolute; top: 0; left: 0; }

        /* Sidebar */
        #sidebar {
            width: 320px; background: var(--panel); border-left: 2px solid var(--border);
            display: flex; flex-direction: column; z-index: 20;
            box-shadow: -5px 0 20px rgba(0,0,0,0.8);
        }
        .panel-header {
            background: #111; padding: 10px; font-weight: bold; color: var(--accent);
            border-bottom: 1px solid var(--border); letter-spacing: 1px; font-size: 11px;
            display: flex; justify-content: space-between; align-items: center;
        }
        #unit-info { padding: 15px; border-bottom: 1px solid var(--border); min-height: 260px; background: #222; }
        #log-container { 
            flex: 1; overflow-y: auto; padding: 10px; 
            font-family: "Lucida Console", monospace; font-size: 11px; 
            background: #000; color: #5c5; text-shadow: 0 0 2px #0f0;
            user-select: text; cursor: text;
        }
        .log-entry { margin-bottom: 4px; border-bottom: 1px solid #222; padding-bottom: 2px; }
        
        button {
            background: linear-gradient(to bottom, #444, #333); border: 1px solid #555;
            color: #ddd; padding: 8px; width: 100%; cursor: pointer;
            font-weight: bold; text-transform: uppercase; margin-top: 5px;
            transition: 0.1s; font-size: 11px;
        }
        button:hover { background: #555; border-color: #777; color: #fff; }
        button:active { transform: translateY(1px); }
        button.disabled { opacity: 0.3; pointer-events: none; filter: grayscale(100%); cursor: not-allowed; }

        .btn-stance { width: 32%; display: inline-block; font-size: 10px; margin: 0; padding: 6px 0; }
        .active-stance { background: #d84; border-color: #fa6; color: #200; box-shadow: 0 0 8px #d84; }
        
        #btn-weapon {
            background: #222; border: 1px solid #d84; color: #d84; margin-bottom: 10px;
            display: flex; justify-content: space-between; align-items: center; padding: 10px; cursor: pointer;
        }
        #btn-weapon:hover { background: #322; color: #fa6; }
        .ap-cost { font-size: 9px; background: #000; color: #d84; padding: 2px 4px; border-radius: 3px; }

        .skill-list { display: flex; flex-wrap: wrap; gap: 4px; margin-top: 5px; }
        .skill-badge {
            background: #234; color: #acf; border: 1px solid #468;
            font-size: 9px; padding: 2px 4px; border-radius: 3px;
        }
        .hero-badge { color: #fd0; border-color: #fd0; background: #430; }

        #auto-toggle {
            position: absolute; bottom: 10px; left: 10px; z-index: 50;
            background: rgba(0,0,0,0.8); border: 1px solid #555; color: #888;
            padding: 5px 10px; cursor: pointer; font-size: 12px; font-weight: bold;
            display: flex; align-items: center; gap: 5px; border-radius: 4px; pointer-events: auto;
        }
        #auto-toggle.active { color: #0f0; border-color: #0f0; box-shadow: 0 0 10px #0f0; }
        .indicator { width: 8px; height: 8px; background: #444; border-radius: 50%; }
        #auto-toggle.active .indicator { background: #0f0; box-shadow: 0 0 5px #0f0; }

        #sector-counter {
            position: absolute; top: 10px; right: 340px; z-index: 50;
            font-size: 24px; font-weight: 900; color: #d84; letter-spacing: 2px;
            text-shadow: 0 0 10px #000; pointer-events: none;
        }

        .overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(10,12,10,0.95); z-index: 100;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
        }
        .card-container { display: flex; gap: 20px; flex-wrap: wrap; justify-content: center; max-width: 900px; }
        
        .card {
            width: 170px; height: 260px; background: #222; border: 2px solid #555;
            padding: 0; display: flex; flex-direction: column; align-items: center;
            cursor: pointer; transition: 0.2s; position: relative; overflow: hidden;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5); user-select: none;
        }
        .card:hover { transform: translateY(-8px) scale(1.02); border-color: var(--accent); z-index: 10; background: #2a2a2a; }
        .card:active { transform: translateY(2px); }
        
        .card-badge {
            position: absolute; top: 5px; right: 5px; background: #d84; color: #000;
            font-weight: bold; padding: 2px 6px; border-radius: 4px; font-size: 14px;
            display: none; box-shadow: 0 0 5px #d84;
        }

        .card-img-box {
            width: 100%; height: 120px; background: #111; 
            border-bottom: 1px solid #444; display: flex; justify-content: center; align-items: center;
            position: relative;
        }
        .card-img-box img { width: 100%; height: auto; image-rendering: pixelated; }

        .card-body { padding: 10px; text-align: center; width: 100%; box-sizing: border-box; }
        .card h3 { color: var(--accent); margin: 5px 0; font-size: 14px; text-transform: uppercase; letter-spacing: 1px; }
        .card p { font-size: 11px; color: #aaa; line-height: 1.4; margin: 5px 0; }

        #eyecatch {
            position: absolute; top: 40%; width: 100%; text-align: center;
            font-size: 48px; font-weight: 900; color: #d33; letter-spacing: 5px;
            text-shadow: 0 0 20px #000; pointer-events: none;
            opacity: 0; transition: opacity 0.5s; z-index: 80;
            background: rgba(0,0,0,0.7); padding: 20px 0; border-top: 2px solid #d33; border-bottom: 2px solid #d33;
        }
        
        #context-menu {
            position: absolute; display: none; background: rgba(0, 20, 30, 0.95);
            border: 1px solid #0af; padding: 10px; width: 220px; color: #fff;
            font-size: 11px; z-index: 50; box-shadow: 0 5px 15px rgba(0,0,0,0.8);
            pointer-events: none;
        }
    </style>
</head>
<body>

<div id="app">
    <div id="game-view">
        <canvas id="cvs"></canvas>
        <div id="sector-counter">SECTOR: 01</div>
        <div id="eyecatch">ENEMY PHASE</div>
        <div id="context-menu"></div>
        <div id="auto-toggle" onclick="game.toggleAuto()">
            <div class="indicator"></div> AUTO PILOT
        </div>
        
        <div id="setup-screen" class="overlay">
            <h1 style="color:#d84; font-size:24px; letter-spacing:2px; border-bottom:2px solid #d84; margin-bottom:20px;">DEPLOYMENT PHASE</h1>
            <p style="color:#ccc; margin-bottom:20px;">部隊を選択してください（残り <span id="slots-left" style="color:#d84; font-weight:bold;">3</span> 枠）</p>
            <div class="card-container" id="setup-cards"></div>
            <button id="btn-start" style="width:200px; margin-top:30px; border:2px solid #d84; background:#421; display:none;" onclick="game.startCampaign()">>>> EXECUTE MISSION</button>
        </div>

        <div id="reward-screen" class="overlay" style="display:none;">
            <h1 style="color:#da4; font-size:32px; text-shadow:0 0 10px #da4;">SECTOR CLEARED!</h1>
            <p style="margin-bottom:20px;">司令部より補給物資が投下されました。</p>
            <div class="card-container" id="reward-cards"></div>
        </div>

        <div id="gameover-screen" class="overlay" style="display:none; background:rgba(30,0,0,0.9);">
            <h1 style="color:#f33; font-size:48px; text-shadow:0 0 20px #f00;">MISSION FAILED</h1>
            <p style="color:#eaa;">全戦力が失われました。</p>
            <button style="width:200px; margin-top:30px; border:2px solid #f33; background:#300;" onclick="location.reload()">RETRY</button>
        </div>
    </div>

    <div id="sidebar">
        <div class="panel-header">SELECTED UNIT</div>
        <div id="unit-info">
            <div style="text-align:center; color:#555; margin-top:80px;">// NO SIGNAL //</div>
        </div>
        
        <div class="panel-header">TACTICAL LOG</div>
        <div id="log-container"></div>
    </div>
</div>

<script>
/** AUDIO ENGINE */
const Sfx = {
    ctx: null,
    init() { if(!this.ctx) this.ctx = new (window.AudioContext||window.webkitAudioContext)(); if(this.ctx.state==='suspended') this.ctx.resume(); },
    noise(dur, freq, type='lowpass', vol=0.2) {
        if(!this.ctx) return; const t=this.ctx.currentTime, b=this.ctx.createBuffer(1,this.ctx.sampleRate*dur,this.ctx.sampleRate), d=b.getChannelData(0);
        for(let i=0;i<d.length;i++)d[i]=(Math.random()*2-1)*Math.exp(-i/(d.length*0.3));
        const s=this.ctx.createBufferSource();s.buffer=b;const f=this.ctx.createBiquadFilter();f.type=type;f.frequency.value=freq;
        const g=this.ctx.createGain();g.gain.setValueAtTime(vol,t);g.gain.exponentialRampToValueAtTime(0.01,t+dur);
        s.connect(f);f.connect(g);g.connect(this.ctx.destination);s.start(t);
    },
    play(id) {
        this.init();
        if(id==='click') this.noise(0.05, 3000, 'highpass', 0.1);
        else if(id==='move') this.noise(0.1, 400, 'lowpass', 0.1);
        else if(id==='swap') this.noise(0.2, 800, 'highpass', 0.2);
        else if(id==='shot') this.noise(0.2, 1200);
        else if(id==='mg') this.noise(0.1, 1500, 'bandpass');
        else if(id==='cannon') { this.noise(0.8, 100, 'lowpass', 0.5); this.noise(0.4, 500, 'lowpass', 0.3); }
        else if(id==='boom') { this.noise(1.0, 60, 'lowpass', 0.8); this.noise(0.5, 200, 'lowpass', 0.5); }
        else if(id==='rocket') { this.noise(1.5, 100, 'lowpass', 0.7); }
        else if(id==='ricochet') { this.noise(0.15, 4500, 'bandpass', 0.3); this.noise(0.1, 2000, 'highpass', 0.1); }
        else if(id==='death') { this.noise(0.4, 200, 'lowpass', 0.6); this.noise(0.2, 1000, 'highpass', 0.3); }
        else if(id==='win') {
            const t = this.ctx.currentTime; [440, 554, 659, 880].forEach((f, i) => {
                const o = this.ctx.createOscillator(); const g = this.ctx.createGain();
                o.type = 'square'; o.frequency.value = f; o.connect(g); g.connect(this.ctx.destination);
                g.gain.setValueAtTime(0.1, t + i*0.15); g.gain.linearRampToValueAtTime(0, t + i*0.15 + 0.4);
                o.start(t + i*0.15); o.stop(t + i*0.15 + 0.4);
            });
        }
    }
};

/** DATA */
const HEX_SIZE = 34; const MAP_W = 24; const MAP_H = 20;
const RANKS = ["Pvt", "Cpl", "Sgt", "Lt", "Cpt", "Maj"];
const SKILLS = {
    "Precision": { name: "精密", desc: "命中+15%" },
    "Radio":     { name: "無線", desc: "支援効果UP" },
    "Ambush":    { name: "隠密", desc: "回避+15%" },
    "AmmoBox":   { name: "弾薬", desc: "連射数UP" },
    "HighPower": { name: "強装", desc: "ダメージ+20%" },
    "Mechanic":  { name: "修理", desc: "毎ターン回復" },
    "Hero":      { name: "英雄", desc: "AP+1 (5戦生存)" }
};

const WPNS = {
    m1: { name:"M1 Garand", rng:6, acc:85, dmg:35, burst:2, type:'bullet' },
    nade: { name:"Grenade", rng:3, acc:70, dmg:80, burst:1, type:'shell', area:true },
    mg42: { name:"MG42", rng:7, acc:50, dmg:20, burst:12, type:'bullet' },
    luger: { name:"Luger P08", rng:3, acc:75, dmg:25, burst:1, type:'bullet' },
    k98: { name:"Scoped K98", rng:9, acc:95, dmg:80, burst:1, type:'bullet' },
    kwk: { name:"75mm AP", rng:7, acc:70, dmg:150, burst:1, type:'shell_fast' },
    he: { name:"75mm HE", rng:7, acc:60, dmg:100, burst:1, type:'shell', area:true },
    rocket380: { name:"380mm Rkt", rng:7, acc:60, dmg:400, burst:1, type:'rocket', area:true },
    coax: { name:"Coax MG", rng:2, acc:60, dmg:15, burst:5, type:'bullet' }
};
const UNITS = {
    infantry: { name:"Rifle Squad", hp:100, ap:4, wpn:"m1", alt:"nade", icon:"⚡", desc:"汎用歩兵分隊" },
    heavy:    { name:"MG Team", hp:120, ap:3, wpn:"mg42", alt:"luger", icon:"⛨", desc:"制圧射撃用重火器" },
    sniper:   { name:"Sniper", hp:60, ap:4, wpn:"k98", alt:"luger", icon:"◎", desc:"長距離狙撃手" },
    tank:     { name:"Panzer IV", hp:550, ap:5, wpn:"kwk", alt:"he", icon:"♜", desc:"中戦車 (姿勢固定)", isTank:true },
    mortar:   { name:"Assault Mortar", hp:400, ap:3, wpn:"rocket380", alt:"mg42", icon:"☢", desc:"突撃臼砲 (広範囲)", isTank:true }
};
const TERRAIN = {
    VOID: {id:-1, name:"", cost:99, cover:0, color:"#111"},
    DIRT: {id:0, name:"荒地", cost:1, cover:5, color:"#5a5245"},
    GRASS:{id:1, name:"草地", cost:1, cover:10, color:"#425030"},
    FOREST:{id:2, name:"森林", cost:2, cover:40, color:"#222e1b"},
    ROAD: {id:3, name:"道路", cost:1, cover:0, color:"#66605a"},
    TOWN: {id:4, name:"廃墟", cost:1, cover:35, color:"#504540"},
    WATER:{id:5, name:"水域", cost:99, cover:0, color:"#303840"}
};

/** HELPER */
function createCardIcon(type) {
    const c = document.createElement('canvas'); c.width=100; c.height=60; const ctx = c.getContext('2d');
    ctx.translate(50, 30); ctx.scale(2,2);
    if(type==='infantry') { ctx.fillStyle="#444"; ctx.fillRect(-15,0,30,4); ctx.fillStyle="#642"; ctx.fillRect(-15,0,10,4); }
    else if(type==='heavy') { ctx.fillStyle="#111"; ctx.fillRect(-10,-2,20,4); ctx.fillRect(-5,2,2,6); ctx.fillRect(5,2,2,6); }
    else if(type==='sniper') { ctx.fillStyle="#222"; ctx.fillRect(-18,0,36,3); ctx.fillRect(-5,-4,10,4); }
    else if(type==='tank') { ctx.fillStyle="#444"; ctx.fillRect(-12,-6,24,12); ctx.fillStyle="#222"; ctx.fillRect(0,-2,16,4); }
    else if(type==='mortar') { ctx.fillStyle="#333"; ctx.fillRect(-14,-8,28,16); ctx.fillStyle="#111"; ctx.beginPath(); ctx.arc(0,-2, 6, 0, Math.PI*2); ctx.fill(); ctx.fillStyle="#522"; ctx.fillRect(-12,-6,4,12); }
    else if(type==='heal') { ctx.fillStyle="#eee"; ctx.fillRect(-10,-8,20,16); ctx.fillStyle="#d00"; ctx.fillRect(-3,-6,6,12); ctx.fillRect(-8,-1,16,2); }
    return c.toDataURL();
}

/** VFX */
const VFX = {
    particles: [], projectiles: [], debris: [], shake: 0,
    add(p) { this.particles.push(p); },
    addProj(p) { this.projectiles.push(p); },
    addStaticDebris(q, r, type) { this.debris.push({q, r, type}); },
    addExplosion(x, y, color="#fa0", count=20) {
        for(let i=0; i<count; i++) {
            const a = Math.random() * Math.PI * 2; const speed = Math.random() * 5 + 1;
            this.add({x, y, vx:Math.cos(a)*speed, vy:Math.sin(a)*speed, life:30+Math.random()*20, maxLife:50, color, size:1+Math.random()*2, type:'spark'});
        }
        for(let i=0; i<10; i++) {
            this.add({x, y, vx:(Math.random()-0.5)*3, vy:(Math.random()-0.5)*3, life:60, maxLife:60, color:"rgba(100,100,100,0.5)", size:4+Math.random()*4, type:'smoke'});
        }
        this.shake = count > 30 ? 20 : 8;
    },
    addUnitDebris(x, y) {
        for(let i=0; i<15; i++) {
            this.add({x, y, vx:(Math.random()-0.5)*8, vy:-Math.random()*8, life:100, maxLife:100, color:Math.random()>0.5?"#888":"#a33", size:Math.random()*3+1, type:'debris'});
        }
    },
    update() {
        if(this.shake>0) this.shake*=0.9; if(this.shake<0.5) this.shake=0;
        this.particles.forEach(p=>{ 
            p.x+=p.vx; p.y+=p.vy; if(p.type==='debris' || p.type==='spark') p.vy+=0.2; p.life--; if(p.type==='debris' && p.vy>0 && Math.random()<0.1) { p.vy *= -0.5; p.vx *= 0.8; }
        });
        this.projectiles.forEach(p=>{
            if(p.type.includes('shell') || p.type === 'rocket') {
                p.progress+=p.speed; if(p.progress>=1) { p.dead=true; p.onHit(); return; }
                const lx = p.sx + (p.ex-p.sx)*p.progress;
                const ly = p.sy + (p.ey-p.sy)*p.progress;
                const arc = Math.sin(p.progress*Math.PI) * p.arcHeight;
                p.x=lx; p.y=ly-arc;
                if(p.type === 'rocket' && Math.random() < 0.5) { VFX.add({x:p.x, y:p.y, vx:(Math.random()-0.5), vy:(Math.random()-0.5), life:20, maxLife:20, color:"#888", size:3, type:'smoke'}); }
            } else { p.x+=p.vx; p.y+=p.vy; p.life--; if(p.life<=0){ p.dead=true; p.onHit(); } }
        });
        this.particles=this.particles.filter(p=>p.life>0); this.projectiles=this.projectiles.filter(p=>!p.dead);
    },
    draw(ctx) {
        ctx.save();
        this.projectiles.forEach(p=>{
            if(p.type.includes('shell')) { ctx.fillStyle="#fff"; ctx.beginPath(); ctx.arc(p.x, p.y, 3, 0, Math.PI*2); ctx.fill(); }
            else if(p.type === 'rocket') { ctx.fillStyle="#f80"; ctx.beginPath(); ctx.arc(p.x, p.y, 5, 0, Math.PI*2); ctx.fill(); }
            else { ctx.strokeStyle="#ffeb3b"; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(p.x-p.vx, p.y-p.vy); ctx.lineTo(p.x, p.y); ctx.stroke(); }
        });
        this.particles.forEach(p=>{
            ctx.fillStyle=p.color; ctx.globalAlpha=p.life/p.maxLife; ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI*2); ctx.fill();
        });
        ctx.restore();
    }
};

/** RENDERER */
const Renderer = {
    ctx: null, canvas: null, cam: {x:0, y:0}, frame:0,
    init(c) { this.canvas=c; this.ctx=c.getContext('2d'); this.resize(); window.addEventListener('resize',()=>this.resize()); },
    resize() { this.canvas.width=this.canvas.parentElement.clientWidth; this.canvas.height=this.canvas.parentElement.clientHeight; },
    centerOn(q, r) { const p=this.hexToPxRaw(q, r); this.cam.x=(this.canvas.width/2)-p.x; this.cam.y=(this.canvas.height/2)-p.y; },
    hexToPx(q,r) { const p=this.hexToPxRaw(q,r); return {x:p.x+this.cam.x, y:p.y+this.cam.y}; },
    hexToPxRaw(q,r) { return {x:HEX_SIZE*3/2*q, y:HEX_SIZE*Math.sqrt(3)*(r+q/2)}; },
    pxToHex(mx,my) { const x=mx-this.cam.x, y=my-this.cam.y; const q=(2/3*x)/HEX_SIZE, r=(-1/3*x+Math.sqrt(3)/3*y)/HEX_SIZE; return this.roundHex(q,r); },
    roundHex(q,r) { let rq=Math.round(q), rr=Math.round(r), rs=Math.round(-q-r); const dq=Math.abs(rq-q), dr=Math.abs(rr-r), ds=Math.abs(rs-(-q-r)); if(dq>dr&&dq>ds) rq=-rr-rs; else if(dr>ds) rr=-rq-rs; return {q:rq, r:rr}; },
    
    drawHex(q,r,t,hlCount) {
        const p=this.hexToPx(q,r);
        if(p.x<-60||p.y<-60||p.x>this.canvas.width+60||p.y>this.canvas.height+60) return;
        const ctx=this.ctx;
        ctx.beginPath(); for(let i=0;i<6;i++) ctx.lineTo(p.x+HEX_SIZE*Math.cos(Math.PI/3*i), p.y+HEX_SIZE*Math.sin(Math.PI/3*i)); ctx.closePath();
        ctx.fillStyle=t.color; ctx.fill();
        
        if(hlCount > 0) {
            const speed = 0.1 + (hlCount * 0.05);
            const pulse = 0.5 + Math.sin(this.frame * speed) * 0.5;
            ctx.strokeStyle=`rgba(255, 200, 50, ${pulse})`; ctx.lineWidth=2 + hlCount*0.5; ctx.stroke();
        } else {
            ctx.strokeStyle="rgba(0,0,0,0.2)"; ctx.lineWidth=1; ctx.stroke();
        }

        ctx.fillStyle="rgba(0,0,0,0.15)";
        if(t===TERRAIN.FOREST) { ctx.beginPath(); ctx.arc(p.x, p.y, HEX_SIZE*0.6, 0, Math.PI*2); ctx.fill(); }
        else if(t===TERRAIN.TOWN) ctx.fillRect(p.x-8, p.y-8, 16, 16);
    },
    drawRange(u) {
        if(!u) return;
        const wpn=WPNS[u.curWpn];
        const ctx=this.ctx;
        const q_min = u.q - wpn.rng, q_max = u.q + wpn.rng;
        for(let q=q_min; q<=q_max; q++) {
            for(let r=u.r-wpn.rng; r<=u.r+wpn.rng; r++) {
                if(Math.abs(q-u.q)+Math.abs(q+r-u.q-u.r)+Math.abs(r-u.r)/2 <= wpn.rng) {
                    if((Math.abs(q-u.q)+Math.abs(q+u.r-u.q-r)+Math.abs(r-u.r))/2 <= wpn.rng) {
                        const p=this.hexToPx(q,r);
                        ctx.fillStyle="rgba(255, 50, 50, 0.15)";
                        ctx.beginPath(); for(let i=0;i<6;i++) ctx.lineTo(p.x+HEX_SIZE*0.9*Math.cos(Math.PI/3*i), p.y+HEX_SIZE*0.9*Math.sin(Math.PI/3*i)); ctx.fill();
                    }
                }
            }
        }
    },
    drawStaticDebris(q, r, type) {
        const p=this.hexToPx(q, r); const ctx=this.ctx;
        if(type==='crater') { ctx.fillStyle="rgba(0,0,0,0.4)"; ctx.beginPath(); ctx.arc(p.x, p.y, 12, 0, Math.PI*2); ctx.fill(); }
        else if(type==='wreck') { ctx.fillStyle="#222"; ctx.fillRect(p.x-10, p.y-10, 20, 15); ctx.fillStyle="#333"; ctx.fillRect(p.x-5, p.y-15, 10, 5); }
    },
    drawUnit(u, sel) {
        const p=this.hexToPx(u.q, u.r); const ctx=this.ctx; ctx.save(); ctx.translate(p.x, p.y);
        
        if(sel) { ctx.beginPath(); ctx.arc(0,0,22,0,Math.PI*2); ctx.strokeStyle="#0f0"; ctx.lineWidth=2; ctx.stroke(); }
        if(u.ap > 0 && u.team === 'player') {
            const ang = this.frame * 0.05; const yOff = -38 + Math.sin(this.frame*0.1)*3;
            ctx.save(); ctx.translate(0, yOff); ctx.rotate(ang); ctx.fillStyle = "#fd0";
            ctx.beginPath(); ctx.moveTo(0,-4); ctx.lineTo(4,0); ctx.lineTo(0,4); ctx.lineTo(-4,0); ctx.fill(); ctx.restore();
        }
        const col = u.team==='player'?'#68a':'#c65';
        if(u.def.isTank) {
            ctx.fillStyle="#222"; ctx.fillRect(-10,-12,4,24); ctx.fillRect(6,-12,4,24);
            ctx.fillStyle=col; ctx.fillRect(-6,-10,12,20);
            ctx.fillStyle="#333"; ctx.beginPath(); ctx.arc(0,0,6,0,Math.PI*2); ctx.fill(); 
            if(u.def.name.includes("Mortar")) ctx.fillRect(0,-4,12,8); else ctx.fillRect(0,-2,20,4);
        } else {
            let h = u.stance === 'prone' ? 3 : (u.stance === 'crouch' ? 5 : 8);
            const pts=[[-6,-6],[6,-6],[0,6]];
            pts.forEach(pt=>{
                ctx.fillStyle="rgba(0,0,0,0.5)"; ctx.beginPath(); ctx.arc(pt[0], pt[1]+2, 4, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle=col; if(u.stance==='prone') ctx.fillRect(pt[0]-5, pt[1]-3, 10, 4); else ctx.fillRect(pt[0]-3, pt[1]-h, 6, h+2);
                ctx.fillStyle="#dcb"; ctx.fillRect(pt[0]-2, pt[1]-h-3, 4, 3);
            });
        }
        ctx.fillStyle="#000"; ctx.fillRect(-10,-22,20,3); ctx.fillStyle=u.hp>u.maxHp/2?"#0f0":"#f00"; ctx.fillRect(-10,-22,20*(u.hp/u.maxHp),3);
        if(u.rank > 0) { ctx.fillStyle="#fd0"; ctx.font="9px monospace"; ctx.fillText(RANKS[Math.min(u.rank,5)] + (u.skills.includes('Hero')?'★':''), -12, -25); }
        ctx.restore();
    }
};

/** LOGIC */
class Game {
    constructor() {
        this.units=[]; this.map=[]; this.setupSlots=[]; this.state='SETUP'; this.path=[]; this.animQueue=[]; this.debris=[]; this.confetti=[]; this.isAuto=false;
        this.isProcessingTurn = false; // ★ FIX: 重複実行防止用フラグ
        this.sector = 1; this.initDOM(); this.initSetup();
        const loop=()=>{ Renderer.frame++; VFX.update(); this.updateConfetti(); this.draw(); if(this.isAuto) this.runAuto(); requestAnimationFrame(loop); }; 
        requestAnimationFrame(loop);
    }

    initDOM() {
        Renderer.init(document.getElementById('cvs'));
        const cvs=document.getElementById('cvs');
        let isDrag=false, lx, ly;
        cvs.addEventListener('mousedown', e=>{
            if(this.state!=='PLAY' || this.isAuto) return;
            if(e.button===2) { this.showContext(e.clientX, e.clientY); return; }
            isDrag=true; lx=e.clientX; ly=e.clientY; this.handleClick(Renderer.pxToHex(e.clientX, e.clientY));
        });
        window.addEventListener('mousemove', e=>{
            if(isDrag) { Renderer.cam.x+=e.clientX-lx; Renderer.cam.y+=e.clientY-ly; lx=e.clientX; ly=e.clientY; }
            else if(this.state==='PLAY') {
                const p=Renderer.pxToHex(e.clientX, e.clientY); this.hoverHex=p;
                if(this.selectedUnit && this.isValidHex(p.q, p.r) && !this.getUnit(p.q, p.r)) this.path=this.findPath(this.selectedUnit, p.q, p.r);
                else this.path=[];
            }
        });
        window.addEventListener('mouseup', ()=>isDrag=false);
        window.addEventListener('contextmenu', e=>e.preventDefault());
        window.addEventListener('click', ()=>document.getElementById('context-menu').style.display='none');
    }

    initSetup() {
        const box=document.getElementById('setup-cards');
        ['infantry','heavy','sniper','tank'].forEach(k=>{
            const u=UNITS[k]; const d=document.createElement('div'); d.className='card';
            d.innerHTML=`<div class="card-badge">x0</div><div class="card-img-box"><img src="${createCardIcon(k)}"></div><div class="card-body"><h3>${u.name}</h3><p>${u.desc}</p></div>`;
            d.onclick=()=>{
                if(this.setupSlots.length<3) {
                    this.setupSlots.push(k);
                    const count = this.setupSlots.filter(s => s === k).length;
                    const badge = d.querySelector('.card-badge');
                    badge.style.display = 'block'; badge.innerText = "x" + count;
                    this.log(`> 選択: ${u.name}`);
                    document.getElementById('slots-left').innerText=3-this.setupSlots.length;
                    if(this.setupSlots.length===3) document.getElementById('btn-start').style.display='block';
                }
            }; box.appendChild(d);
        });
    }

    startCampaign() {
        document.getElementById('setup-screen').style.display='none'; Renderer.resize();
        this.generateMap();
        if(this.units.length === 0) { this.setupSlots.forEach(k=>this.spawnAtSafeGround('player',k)); }
        else { this.units.filter(u=>u.team==='player').forEach(u=>{ u.q=null; this.spawnAtSafeGround('player',null,u); }); }
        this.spawnEnemies();
        this.state='PLAY'; 
        this.log(`MISSION START - SECTOR ${this.sector}`);
        document.getElementById('sector-counter').innerText = `SECTOR: ${this.sector.toString().padStart(2, '0')}`;
        this.confetti=[]; VFX.debris=[];
        if(this.units.length>0) Renderer.centerOn(this.units[0].q, this.units[0].r);
    }

    generateMap() {
        this.map=[]; const cx=MAP_W/2, cy=MAP_H/2;
        for(let q=0; q<MAP_W; q++) {
            this.map[q]=[];
            for(let r=0; r<MAP_H; r++) {
                const dx=q-cx, dy=r-cy; const dist=Math.sqrt(dx*dx + dy*dy);
                const noise=Math.sin(q*0.4)+Math.cos(r*0.4)+Math.random()*0.4;
                let t=TERRAIN.VOID;
                if(dist<7+noise) { t=TERRAIN.GRASS; if(noise>1) t=TERRAIN.FOREST; else if(noise<-0.8) t=TERRAIN.DIRT; if(dist>6+noise) t=TERRAIN.DIRT; }
                else t=TERRAIN.WATER;
                if(t!==TERRAIN.WATER && Math.random()<0.04) t=TERRAIN.TOWN;
                this.map[q][r]=t;
            }
        }
    }

    spawnEnemies() {
        const count = 4 + Math.floor(this.sector * 0.7);
        const tankChance = Math.min(0.8, 0.1 + (this.sector * 0.1));
        for(let i=0; i<count; i++) {
            let k = 'infantry'; const rnd = Math.random();
            if (rnd < tankChance) k = 'tank'; else if (rnd < tankChance + 0.3) k = 'heavy'; else if (rnd < tankChance + 0.5) k = 'sniper';
            const enemy = this.spawnAtSafeGround('enemy', k);
            if(enemy) { 
                enemy.rank = Math.floor(Math.random() * Math.min(5, this.sector/2)); enemy.maxHp+=enemy.rank*30; enemy.hp=enemy.maxHp; 
                if(this.sector > 2 && Math.random() < 0.4) {
                    const sk = Object.keys(SKILLS);
                    enemy.skills = [sk[Math.floor(Math.random()*sk.length)]];
                }
            }
        }
    }

    spawnAtSafeGround(team, key, existingUnit=null) {
        let q, r, tries=0;
        do { 
            q=Math.floor(Math.random()*MAP_W); r=Math.floor(Math.random()*MAP_H); tries++; 
            if(team==='player' && r < MAP_H/2) continue;
            if(team==='enemy' && r > MAP_H/2) continue;
        } 
        while((!this.isValidHex(q,r) || this.map[q][r].cost>=99 || this.getUnit(q,r)) && tries<500);

        if(tries<500) {
            if(existingUnit) { existingUnit.q=q; existingUnit.r=r; return existingUnit; }
            else return this.spawnUnit(team, key, q, r);
        } return null;
    }

    spawnUnit(team, k, q, r) {
        const def=UNITS[k];
        const apMod = (def.ap + (k==='tank'?0:0));
        this.units.push({
            id:Math.random(), team, q, r, def, 
            hp:def.hp, maxHp:def.hp, ap:apMod, maxAp:apMod, 
            stance:'stand', curWpn:def.wpn, rank:0, deadProcessed:false,
            skills: [], sectorsSurvived: 0
        });
    }

    toggleAuto() {
        this.isAuto = !this.isAuto;
        document.getElementById('auto-toggle').classList.toggle('active');
        this.log(`AUTO PILOT: ${this.isAuto ? "ON" : "OFF"}`);
        this.selectedUnit = null; this.path = [];
        // ★ FIX: オートパイロット切り替え時に即座にチェック
        if(this.isAuto) this.runAuto();
    }

    autoTimer = 0;
    runAuto() {
        if(this.state !== 'PLAY' || this.autoTimer > 0) { if(this.autoTimer>0) this.autoTimer--; return; }
        const active = this.units.filter(u => u.team==='player' && u.hp>0 && u.ap>0);
        if(active.length === 0) { this.endTurn(); return; }
        const u = active[0];
        const enemies = this.units.filter(e => e.team==='enemy' && e.hp>0);
        if(enemies.length===0) return;
        let target = enemies[0], score = -9999;
        enemies.forEach(e => { const d = this.hexDist(u, e); let val = (100 - e.hp) * 2 - (d * 10); if(val > score) { score=val; target=e; } });
        const wpn = WPNS[u.curWpn]; const dist = this.hexDist(u, target);
        if(dist <= wpn.rng && u.ap >= 2) { this.actionAttack(u, target); this.autoTimer = 80; } 
        else {
            const path = this.findPath(u, target.q, target.r);
            if(path.length > 0 && path[0].q && this.map[path[0].q][path[0].r].cost <= u.ap) {
                u.q = path[0].q; u.r = path[0].r; u.ap -= this.map[u.q][u.r].cost; Sfx.play('move'); this.autoTimer = 20; this.checkReactionFire(u);
            } else u.ap = 0;
        }
    }

    handleClick(p) {
        if(!this.isValidHex(p.q, p.r)) return;
        const u=this.getUnit(p.q, p.r);
        if(u && u.team==='player') { this.selectedUnit=u; Sfx.play('click'); this.updateSidebar(); }
        else if(this.selectedUnit) {
            if(u && u.team==='enemy') this.actionAttack(this.selectedUnit, u);
            else if(!u && this.path.length>0) this.actionMove(this.selectedUnit, this.path);
        }
    }

    async actionMove(u, path) {
        this.state='ANIM'; this.selectedUnit=null; this.path=[];
        for(let s of path) {
            u.ap-=this.map[s.q][s.r].cost; u.q=s.q; u.r=s.r;
            Sfx.play('move'); await new Promise(r=>setTimeout(r,180));
        }
        this.checkReactionFire(u);
        this.state='PLAY'; if(u.ap>0) this.selectedUnit=u; this.updateSidebar(); this.checkPhaseEnd();
    }

    checkReactionFire(u) {
        const enemies = this.units.filter(e => e.team !== u.team && e.hp > 0 && e.def.isTank && this.hexDist(u, e) <= 2);
        enemies.forEach(tank => {
            this.log(`!! 近接防御射撃: ${tank.def.name} -> ${u.def.name}`);
            u.hp -= 15; VFX.addExplosion(Renderer.hexToPx(u.q,u.r).x, Renderer.hexToPx(u.q,u.r).y, "#ffaa00", 5); Sfx.play('mg');
            if(u.hp<=0 && !u.deadProcessed) { u.deadProcessed=true; this.log(`${u.def.name} 撃破`); Sfx.play('death'); }
        });
    }

    swapWeapon() {
        if(this.selectedUnit && this.selectedUnit.ap >= 1) {
            const u = this.selectedUnit; u.ap--;
            u.curWpn = (u.curWpn === u.def.wpn) ? u.def.alt : u.def.wpn;
            Sfx.play('swap'); this.log(`${u.def.name} 武装変更: ${WPNS[u.curWpn].name}`);
            this.updateSidebar();
        }
    }

    async actionAttack(atk, def) {
        if(atk.ap<2) { this.log("AP不足!"); return; }
        const wpn=WPNS[atk.curWpn];
        if(this.hexDist(atk, def) > wpn.rng) { this.log("射程外です"); return; }
        
        atk.ap-=2; this.state='ANIM';
        
        let bonus = this.getNeighbors(atk.q, atk.r).filter(n => this.getUnit(n.q, n.r)?.team === atk.team).length * 10;
        if(atk.skills.includes("Radio")) bonus += 15;
        
        let accMod = (atk.rank || 0) * 8; 
        if(atk.skills.includes("Precision")) accMod += 15;

        let dmgMod = 1.0;
        if(atk.skills.includes("HighPower")) dmgMod = 1.2;

        this.log(`${atk.def.name} 攻撃(支援+${bonus}%)`);
        
        let burst=wpn.burst||1;
        if(atk.skills.includes("AmmoBox")) burst += (wpn.name==='MG42'?3:1);

        const pType = wpn.type; const isShell = pType.includes('shell');
        const isRocket = pType === 'rocket'; 

        for(let i=0; i<burst; i++) {
            if(def.hp <= 0 && !isRocket) break;
            Sfx.play(isRocket ? 'rocket' : (isShell?'cannon':(burst>1?'mg':'shot')));
            const s=Renderer.hexToPx(atk.q, atk.r), e=Renderer.hexToPx(def.q, def.r);
            const ex=e.x+(Math.random()-0.5)*10, ey=e.y+(Math.random()-0.5)*10;
            const proj = { 
                x:s.x, y:s.y, sx:s.x, sy:s.y, ex:ex, ey:ey, type:pType, progress:0, 
                speed: isRocket ? 0.02 : (pType==='shell_fast'? 0.1 : 0.05),
                arcHeight: isRocket ? 250 : (isShell?(pType==='shell_fast'?40:120):0),
                onHit: () => {
                    if (isRocket) {
                        VFX.addExplosion(ex, ey, "#fa0", 50); Sfx.play('boom');
                        [{q:def.q, r:def.r}, ...this.getNeighbors(def.q, def.r)].forEach(loc => {
                            const v = this.getUnit(loc.q, loc.r);
                            if(v) {
                                let dmg = wpn.dmg * dmgMod; 
                                v.hp -= dmg;
                                this.log(`>> 爆風: ${v.def.name} (-${Math.floor(dmg)})`);
                                if(v.hp<=0 && !v.deadProcessed) { v.deadProcessed = true; this.log(`${v.def.name} 爆散`); VFX.addUnitDebris(Renderer.hexToPx(v.q,v.r).x, Renderer.hexToPx(v.q,v.r).y); VFX.addStaticDebris(v.q, v.r, v.def.isTank ? 'wreck' : 'crater'); }
                            }
                        });
                    } else {
                        if(def.hp <= 0) return;
                        let hit = wpn.acc - this.map[def.q][def.r].cover + accMod;
                        if(def.stance==='prone') hit-=25;
                        if(def.skills && def.skills.includes("Ambush")) hit-=15;

                        if(Math.random()*100 < hit) {
                            let dmg = Math.floor(wpn.dmg * (1+bonus/100) * (0.8+Math.random()*0.4) * dmgMod);
                            if(def.stance==='prone') dmg=Math.floor(dmg*0.6);
                            def.hp-=dmg; 
                            VFX.addExplosion(ex, ey, "#f55", 5); Sfx.play(isShell?'boom':'shot');
                            if(wpn.area || Math.random() < 0.2) {
                                this.getNeighbors(def.q, def.r).forEach(n=>{
                                    const v = this.getUnit(n.q, n.r);
                                    if(v && Math.random()<0.4){ v.hp-=10; if(v.hp<=0 && !v.deadProcessed) { v.deadProcessed=true; this.log(`${v.def.name} 爆散`); VFX.addUnitDebris(Renderer.hexToPx(v.q,v.r).x, Renderer.hexToPx(v.q,v.r).y); } }
                                });
                            }
                        } else { Sfx.play('ricochet'); VFX.add({x:ex,y:ey,vx:(Math.random()-0.5)*5,vy:-5,life:5,maxLife:5,color:"#fff",size:2,type:'spark'}); }
                    }
                }
            };
            if(!isShell && !isRocket) { 
                const dx=ex-s.x, dy=ey-s.y, ang=Math.atan2(dy,dx); 
                proj.vx=Math.cos(ang)*25; proj.vy=Math.sin(ang)*25; proj.life=Math.sqrt(dx*dx+dy*dy)/25; 
            }
            VFX.addProj(proj);
            await new Promise(r=>setTimeout(r, isRocket ? 800 : (isShell?200:40)));
        }
        
        setTimeout(() => { 
            const dead = this.units.filter(u=>u.hp<=0);
            dead.forEach(d => {
                if(!d.deadProcessed) {
                    d.deadProcessed = true; if(d === def) { this.log(`${d.def.name} 撃破`); Sfx.play('death'); }
                    VFX.addUnitDebris(Renderer.hexToPx(d.q,d.r).x, Renderer.hexToPx(d.q,d.r).y);
                    VFX.addStaticDebris(d.q, d.r, d.def.isTank ? 'wreck' : 'crater');
                }
            });
            if (this.checkWin()) return; this.checkLose();
            this.state='PLAY'; this.updateSidebar(); this.checkPhaseEnd();
        }, isRocket ? 1200 : 500);
    }

    checkPhaseEnd() { if(this.units.filter(u=>u.team==='player'&&u.hp>0&&u.ap>0).length===0 && this.state==='PLAY') this.endTurn(); }
    setStance(s) { if(this.selectedUnit && this.selectedUnit.ap>=1 && !this.selectedUnit.def.isTank) { this.selectedUnit.ap--; this.selectedUnit.stance=s; this.updateSidebar(); this.checkPhaseEnd(); } }

    endTurn() {
        if(this.isProcessingTurn) return; // ★ FIX: 既に処理中なら何もしない（連打ガード）
        this.isProcessingTurn = true;     // ★ FIX: ロック開始

        this.selectedUnit=null; this.state='ANIM'; document.getElementById('eyecatch').style.opacity=1;
        
        // Mechanic Heal
        this.units.filter(u=>u.team==='player'&&u.hp>0&&u.skills.includes("Mechanic")).forEach(u=>{
            if(u.hp < u.maxHp) { u.hp = Math.min(u.maxHp, u.hp+20); this.log(`${u.def.name} 自己修復`); }
        });

        setTimeout(async () => {
            document.getElementById('eyecatch').style.opacity=0;
            const enemies=this.units.filter(u=>u.team==='enemy'&&u.hp>0);
            for(let e of enemies) {
                const players=this.units.filter(u=>u.team==='player'&&u.hp>0); if(players.length===0) { this.checkLose(); break; }
                e.ap=e.maxAp; let target=players[0], minDist=999;
                players.forEach(p=>{ const d=this.hexDist(e,p); if(d<minDist){minDist=d; target=p;} });
                if(minDist <= 6) {
                    if(minDist<=4 && e.ap>=1 && !e.def.isTank) e.stance='crouch';
                    await this.actionAttack(e, target);
                } else { 
                    const nq=e.q+(target.q>e.q?1:-1); if(!this.getUnit(nq,e.r)&&this.isValidHex(nq,e.r)&&this.map[nq][e.r].cost<99){ e.q=nq; e.ap--; await new Promise(r=>setTimeout(r,200)); } 
                }
            }
            this.units.forEach(u=>{if(u.team==='player') u.ap=u.maxAp;}); this.log("-- PLAYER PHASE --"); this.state='PLAY';
            this.isProcessingTurn = false; // ★ FIX: ロック解除
        }, 1200);
    }

    healSurvivors() {
        this.units.filter(u=>u.team==='player'&&u.hp>0).forEach(u=>{ 
            const target=Math.floor(u.maxHp*0.8); if(u.hp<target)u.hp=target; 
        });
        this.log("生存部隊 治療完了 (MAX 80%)");
    }
    promoteSurvivors() {
        const skKeys = Object.keys(SKILLS);
        this.units.filter(u=>u.team==='player'&&u.hp>0).forEach(u=>{ 
            u.sectorsSurvived++;
            if(u.sectorsSurvived === 5) {
                u.skills.push("Hero");
                u.maxAp += 1;
                this.log(`${u.def.name} 【英雄】昇格 (AP+1)`);
            }
            
            u.rank=Math.min(5, (u.rank||0)+1); u.maxHp+=30; u.hp+=30; 
            // Gain Perk
            if(u.skills.length < 3 && Math.random() < 0.6) {
                const newSkill = skKeys[Math.floor(Math.random()*skKeys.length)];
                if(!u.skills.includes(newSkill) && newSkill !== "Hero") {
                    u.skills.push(newSkill);
                    this.log(`${u.def.name} 新戦技習得: ${SKILLS[newSkill].name}`);
                }
            }
            this.log(`${u.def.name} 昇進 -> ${RANKS[u.rank]}`); 
        });
    }

    checkWin() {
        if(this.units.filter(u=>u.team==='enemy'&&u.hp>0).length===0) {
            Sfx.play('win'); this.createConfetti(); document.getElementById('reward-screen').style.display='flex';
            this.promoteSurvivors(); 
            const box=document.getElementById('reward-cards'); box.innerHTML='';
            const options = [{k:'infantry',t:'新兵'},{k:'tank',t:'戦車'},{k:'heal',t:'医療支援'}];
            if(Math.random()<0.3) options.push({k:'mortar',t:'突撃臼砲'});
            options.forEach(opt=>{
                const d=document.createElement('div'); d.className='card';
                const img = opt.k==='heal' ? createCardIcon('heal') : createCardIcon(opt.k);
                d.innerHTML=`<div class="card-img-box"><img src="${img}"></div><div class="card-body"><h3>${opt.t}</h3><p>補給実行</p></div>`;
                d.onclick=()=>{ 
                    if(opt.k==='heal') this.healSurvivors(); else this.spawnAtSafeGround('player', opt.k);
                    this.sector++; document.getElementById('reward-screen').style.display='none'; this.startCampaign();
                }; box.appendChild(d);
            });
            return true;
        }
        return false;
    }
    
    checkLose() { if(this.units.filter(u=>u.team==='player'&&u.hp>0).length===0) document.getElementById('gameover-screen').style.display='flex'; }

    createConfetti() { for(let i=0; i<100; i++) this.confetti.push({x:Math.random()*Renderer.canvas.width, y:-Math.random()*500, c:`hsl(${Math.random()*360},80%,50%)`, s:Math.random()*3+2, v:Math.random()*3+3}); }
    updateConfetti() { this.confetti.forEach(p=>{ p.y+=p.v; p.x+=Math.sin(p.y*0.05); if(p.y>Renderer.canvas.height) p.y=-10; Renderer.ctx.fillStyle=p.c; Renderer.ctx.fillRect(p.x,p.y,p.s,p.s); }); }
    getUnit(q,r){return this.units.find(u=>u.q===q&&u.r===r&&u.hp>0);}
    isValidHex(q,r){return q>=0&&q<MAP_W&&r>=0&&r<MAP_H;}
    hexDist(a,b){return (Math.abs(a.q-b.q)+Math.abs(a.q+a.r-b.q-b.r)+Math.abs(a.r-b.r))/2;}
    getNeighbors(q,r){ const dirs=[[1,0],[1,-1],[0,-1],[-1,0],[-1,1],[0,1]]; return dirs.map(d=>({q:q+d[0],r:r+d[1]})).filter(h=>this.isValidHex(h.q,h.r)); }
    findPath(u,tq,tr){
        let frontier=[{q:u.q,r:u.r}], cameFrom={}, costSoFar={}; cameFrom[`${u.q},${u.r}`]=null; costSoFar[`${u.q},${u.r}`]=0;
        while(frontier.length>0){
            let cur=frontier.shift(); if(cur.q===tq&&cur.r===tr) break;
            this.getNeighbors(cur.q,cur.r).forEach(n=>{
                if(this.getUnit(n.q,n.r)&&(n.q!==tq||n.r!==tr)) return;
                let c=this.map[n.q][n.r].cost; if(c>=99) return;
                let nc=costSoFar[`${cur.q},${cur.r}`]+c;
                if(nc<=u.ap){ let k=`${n.q},${n.r}`; if(!(k in costSoFar)||nc<costSoFar[k]){ costSoFar[k]=nc; frontier.push(n); cameFrom[k]=cur; } }
            });
        }
        let p=[], c={q:tq,r:tr}; if(!cameFrom[`${tq},${tr}`]) return [];
        while(c){ if(c.q===u.q&&c.r===u.r) break; p.push(c); c=cameFrom[`${c.q},${c.r}`]; } return p.reverse();
    }
    log(m){ const c=document.getElementById('log-container'); const d=document.createElement('div'); d.className='log-entry'; d.innerText=`> ${m}`; c.appendChild(d); c.scrollTop=c.scrollHeight; }
    showContext(mx,my) {
        const p=Renderer.pxToHex(mx,my), m=document.getElementById('context-menu'), u=this.getUnit(p.q,p.r), t=this.isValidHex(p.q,p.r)?this.map[p.q][p.r]:null;
        if(u) m.innerHTML=`<div style="color:#0af;font-weight:bold">${u.def.name}</div>HP: ${u.hp}/${u.maxHp}<br>AP: ${u.ap}<br>Wpn: ${WPNS[u.curWpn].name}`;
        else if(t && t.id!==-1) m.innerHTML=`<div style="color:#0af;font-weight:bold">${t.name}</div>コスト: ${t.cost}<br>防御: ${t.cover}%`;
        else return;
        m.style.display='block'; m.style.left=mx+'px'; m.style.top=my+'px';
    }
    getStatus(u) { if(u.hp<=0)return "DEAD"; const r=u.hp/u.maxHp; if(r>0.8)return "NORMAL"; if(r>0.5)return u.def.isTank?"TRACK DMG":"LIGHT W."; if(r>0.2)return u.def.isTank?"GUN DMG":"HEAVY W."; return "CRITICAL"; }
    updateSidebar() {
        const ui=document.getElementById('unit-info'), u=this.selectedUnit;
        if(u) {
            const wpn = WPNS[u.curWpn], st=this.getStatus(u), rank=RANKS[u.rank||0];
            const skillBadges = u.skills.map(s => {
                const cls = s==="Hero" ? "skill-badge hero-badge" : "skill-badge";
                return `<span class="${cls}">${SKILLS[s].name}</span>`;
            }).join('');
            
            const btnState = (this.state !== 'PLAY') ? 'disabled' : '';

            ui.innerHTML=`<h2 style="color:#d84; margin:0 0 5px 0;">${u.def.name}</h2>
                <div style="font-size:10px;color:#888;margin-bottom:5px;">RANK: <span style="color:#fd0">${rank}</span> | STATUS: <span style="color:${u.hp/u.maxHp<0.3?'#f55':'#5f5'}">${st}</span></div>
                <div class="skill-list">${skillBadges}</div>
                HP: ${u.hp}/${u.maxHp} AP: ${u.ap}/${u.maxAp}<br>
                <div id="btn-weapon" onclick="game.swapWeapon()"><div><small>Main:</small> ${wpn.name}</div><div class="ap-cost">SWAP(1)</div></div>
                <div>射程: ${wpn.rng} / 威力: ${wpn.dmg}</div>
                <div style="margin-top:15px;"><button class="btn-stance ${u.stance==='stand'?'active-stance':''}" onclick="game.setStance('stand')">立</button>
                <button class="btn-stance ${u.stance==='crouch'?'active-stance':''}" onclick="game.setStance('crouch')">屈</button>
                <button class="btn-stance ${u.stance==='prone'?'active-stance':''}" onclick="game.setStance('prone')">伏</button></div>
                <button onclick="game.endTurn()" class="${btnState}" style="background:#522; border-color:#d44; margin-top:20px;">TURN END</button>`;
            if(u.def.isTank) document.querySelectorAll('.btn-stance').forEach(b=>b.classList.add('disabled'));
        } else ui.innerHTML=`<div style="text-align:center; color:#555; margin-top:80px;">// NO SIGNAL //</div>`;
    }
    draw() {
        const ctx=Renderer.ctx; 
        if(Renderer.shake > 0) { ctx.save(); ctx.translate((Math.random()-0.5)*Renderer.shake, (Math.random()-0.5)*Renderer.shake); }
        ctx.fillStyle="#0b0e0a"; ctx.fillRect(0,0,Renderer.canvas.width,Renderer.canvas.height);
        
        if(this.map.length>0) {
            let neighborCounts = new Map();
            const players = this.units.filter(u => u.team === 'player' && u.hp > 0);
            players.forEach(u => {
                let count = this.getNeighbors(u.q, u.r).filter(n => this.getUnit(n.q, n.r)?.team === 'player').length;
                if (count > 0) neighborCounts.set(`${u.q},${u.r}`, count);
            });

            for(let q=0; q<MAP_W; q++) for(let r=0; r<MAP_H; r++) { 
                if(this.map[q][r].id!==-1) {
                    const count = neighborCounts.get(`${q},${r}`) || 0;
                    Renderer.drawHex(q, r, this.map[q][r], count); 
                    VFX.debris.filter(d=>d.q===q&&d.r===r).forEach(d=>Renderer.drawStaticDebris(d.q,d.r,d.type));
                }
            }
        }
        
        // Range & Path
        if(this.selectedUnit && this.state==='PLAY') Renderer.drawRange(this.selectedUnit);
        
        if(this.path.length>0) { ctx.strokeStyle="rgba(255,255,255,0.4)"; ctx.lineWidth=2; ctx.setLineDash([5,5]); ctx.beginPath(); 
            const s=Renderer.hexToPx(this.selectedUnit.q,this.selectedUnit.r); ctx.moveTo(s.x,s.y); this.path.forEach(p=>{const px=Renderer.hexToPx(p.q,p.r); ctx.lineTo(px.x,px.y);}); ctx.stroke(); ctx.setLineDash([]); }
        
        this.units.sort((a,b)=>a.r-b.r); this.units.forEach(u=>{ if(u.hp>0) Renderer.drawUnit(u, u===this.selectedUnit); });
        
        VFX.draw(ctx); if(Renderer.shake > 0) ctx.restore();
        if(this.selectedUnit && this.hoverHex) { const t=this.getUnit(this.hoverHex.q,this.hoverHex.r); if(t && t.team==='enemy') { 
            const s=Renderer.hexToPx(this.selectedUnit.q,this.selectedUnit.r), e=Renderer.hexToPx(t.q,t.r);
            ctx.strokeStyle="rgba(255,50,50,0.5)"; ctx.lineWidth=1; ctx.beginPath(); ctx.moveTo(s.x,s.y); ctx.lineTo(e.x,e.y); ctx.stroke(); } }
    }
}
const game = new Game();
</script>
</body>
</html>